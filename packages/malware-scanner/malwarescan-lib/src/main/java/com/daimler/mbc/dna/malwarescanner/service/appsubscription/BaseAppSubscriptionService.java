/* LICENSE START
 * 
 * MIT License
 * 
 * Copyright (c) 2019 Daimler TSS GmbH
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * LICENSE END 
 */

package com.daimler.mbc.dna.malwarescanner.service.appsubscription;

import com.daimler.mbc.dna.malwarescanner.app.auth.UserStore;
import com.daimler.mbc.dna.malwarescanner.app.config.VaultConfig;
import com.daimler.mbc.dna.malwarescanner.assembler.AppSubscriptionAssembler;
import com.daimler.mbc.dna.malwarescanner.client.DnaClient;
import com.daimler.mbc.dna.malwarescanner.db.entities.AppSubscriptionNsql;
import com.daimler.mbc.dna.malwarescanner.db.repo.appsubscription.AppSubscriptionCustomRepository;
import com.daimler.mbc.dna.malwarescanner.db.repo.appsubscription.AppSubscriptionRepository;
import com.daimler.mbc.dna.malwarescanner.dto.VaultGenericResponse;
import com.daimler.mbc.dna.malwarescanner.dto.appsubscription.*;
import com.daimler.mbc.dna.malwarescanner.exceptions.GenericMessage;
import com.daimler.mbc.dna.malwarescanner.exceptions.MessageDescription;
import com.daimler.mbc.dna.malwarescanner.service.common.BaseCommonService;
import com.daimler.mbc.dna.malwarescanner.util.ConstantsUtility;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.vault.support.VaultResponse;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class BaseAppSubscriptionService extends BaseCommonService<SubscriptionVO, AppSubscriptionNsql, String>
		implements AppSubscriptionService {

	private static Logger LOGGER = LoggerFactory.getLogger(BaseAppSubscriptionService.class);

	@Autowired
	private AppSubscriptionCustomRepository customRepo;
	@Autowired
	private AppSubscriptionRepository jpaRepo;
	@Autowired
	private AppSubscriptionAssembler appSubscriptionAssembler;

	@Autowired
	private VaultConfig vaultConfig;

	@Autowired
	private UserStore userStore;

	@Autowired
	private DnaClient dnaClient;

	public BaseAppSubscriptionService() {
		super();
	}

	/**
	 * <p>
	 * To validate application key.
	 * </p>
	 * 
	 * @param ApiKeyValidationVO
	 */
	@Override
	public ApiKeyValidationResponseVO validateApiKey(ApiKeyValidationVO apiKeyValidationVO) {
		ApiKeyValidationResponseVO validationResponseVO = new ApiKeyValidationResponseVO();
		List<MessageDescription> messages = new ArrayList<>();
		MessageDescription message = null;
		String uniqueAppId = apiKeyValidationVO.getAppId();
		SubscriptionVO existingSubscriptionVO = super.getByUniqueliteral("appId", apiKeyValidationVO.getAppId());
		if (existingSubscriptionVO != null && StringUtils.hasText(existingSubscriptionVO.getAppId())) {
			if (StringUtils.hasText(existingSubscriptionVO.getRecordStatus())
					&& existingSubscriptionVO.getRecordStatus().equals(ConstantsUtility.DELETED)) {
				LOGGER.info("Subscription is deleted by owner/admin for appId {} ", uniqueAppId);
				message = new MessageDescription();
				message.setMessage("Subscription is deleted by owner/admin.");
				messages.add(message);
				validationResponseVO.setValidApiKey(false);
			} else if (existingSubscriptionVO.getExpireOn() != null
					&& existingSubscriptionVO.getExpireOn().before(new Date())) {
				LOGGER.info("Subscription is expired please contact admin. appId {} ", uniqueAppId);
				message = new MessageDescription();
				message.setMessage("Subscription is expired please contact admin.");
				messages.add(message);
				validationResponseVO.setValidApiKey(false);
			} else {
				LOGGER.debug("Entering validateApiKey for appId {}", uniqueAppId);
				VaultGenericResponse vaultResponse = vaultConfig.validateApiKey(apiKeyValidationVO.getAppId(),
						apiKeyValidationVO.getApiKey());
				if (vaultResponse != null && "200".equals(vaultResponse.getStatus())) {
					LOGGER.info("Valid apikey for appId {}", uniqueAppId);
					existingSubscriptionVO.setUsageCount(
							existingSubscriptionVO.getUsageCount() != null ? existingSubscriptionVO.getUsageCount() + 1
									: 1);
					existingSubscriptionVO.setLastUsedOn(new Date());
					super.create(existingSubscriptionVO);
					validationResponseVO.setValidApiKey(true);
				} else {
					message = new MessageDescription();
					LOGGER.info("Failed to validate apikey for appId {}", uniqueAppId);
					message.setMessage("Failed to validate");
					messages.add(message);
					validationResponseVO.setValidApiKey(false);
				}
			}
		} else {
			message = new MessageDescription();
			LOGGER.info("Api Key is invalid for appId {}", uniqueAppId);
			message.setMessage("Api Key is invalid");
			messages.add(message);
			validationResponseVO.setValidApiKey(false);
		}

		validationResponseVO.setData(apiKeyValidationVO);
		if (!ObjectUtils.isEmpty(messages)) {
			validationResponseVO.setErrors(messages);
		} else {
			validationResponseVO.setErrors(null);
		}

		return validationResponseVO;
	}

	/**
	 * create/update api key in vault
	 * 
	 * @param SubscriptionVO
	 * @return SubscriptionVO
	 */
	@Override
	@Transactional
	public SubscriptionVO createApiKey(SubscriptionVO requestSubscriptionVO, String userId) {
		String appId = UUID.randomUUID().toString();
		String apiKey = UUID.randomUUID().toString();
		VaultGenericResponse vaultResponse = vaultConfig.createApiKey(appId, apiKey);
		if (vaultResponse != null && "200".equals(vaultResponse.getStatus())) {
			LOGGER.info("Valid apikey");
			requestSubscriptionVO.setAppId(appId);
			requestSubscriptionVO.setApiKey(apiKey);
			requestSubscriptionVO.setCreatedBy(userId);
			requestSubscriptionVO.setCreatedDate(new Date());
			requestSubscriptionVO.setUpdatedBy(userId);
			requestSubscriptionVO.setUpdatedDate(new Date());
			requestSubscriptionVO.setRecordStatus(ConstantsUtility.OPEN);
			requestSubscriptionVO.setUsageCount(0);
			SubscriptionVO responseSubscriptionVO = super.create(requestSubscriptionVO);
			responseSubscriptionVO.setApiKey(apiKey);
			return responseSubscriptionVO;
		} else {
			return null;
		}
	}

	/**
	 * get All Subscription details based on filter
	 * 
	 * @param userId
	 * @param isAdmin
	 * @param offset
	 * @param limit
	 * @return List<SubscriptionVO>
	 */
	@Override
	@Transactional
	public List<SubscriptionVO> getAllWithFilters(String userId, boolean isAdmin, String recordStatus, String appId,
			String sortBy, String sortOrder, int offset, int limit, String searchTerm) {
		List<AppSubscriptionNsql> appSubscriptionEntities = customRepo.getAllWithFilters(userId, isAdmin, recordStatus,
				appId, sortBy, sortOrder, offset, limit, null, searchTerm);
		if (!ObjectUtils.isEmpty(appSubscriptionEntities)) {
			List<SubscriptionVO> SubscriptionsVO = appSubscriptionEntities.stream()
					.map(n -> appSubscriptionAssembler.toVo(n)).collect(Collectors.toList());
			for (SubscriptionVO subscriptionVO : SubscriptionsVO) {
				VaultResponse vaultResponse = vaultConfig.getApiKeys(subscriptionVO.getAppId());
				if (vaultResponse != null && vaultResponse.getData() != null
						&& vaultResponse.getData().get(subscriptionVO.getAppId()) != null) {
					subscriptionVO.setApiKey(vaultResponse.getData().get(subscriptionVO.getAppId()).toString());
				}
			}
			return SubscriptionsVO;
		} else {
			return new ArrayList<>();
		}

	}

	/**
	 * get count of subscribed application
	 * 
	 * @param userId
	 * @param isAdmin
	 */
	@Override
	@Transactional
	public Long getCount(String userId, boolean isAdmin, String recordStatus, String appId, String searchTerm) {
		return customRepo.getCount(userId, isAdmin, recordStatus, appId, searchTerm);
	}

	/**
	 * Delete a subscription with given identifier
	 * 
	 * @param id
	 * @param userId
	 * @param existingSubscriptionVO
	 */
	@Override
	@Transactional
	public ResponseEntity<GenericMessage> deleteSubscriptionById(String id) {
		SubscriptionVO existingSubscriptionVO = super.getById(id);
		CreatedByVO currentUser = this.userStore.getVO();
		String userId = currentUser != null ? currentUser.getId() : "";
		boolean isAdmin = false;
		boolean isOwner = false;
		if (StringUtils.hasText(userId)) {
			isAdmin = this.userStore.getUserInfo().hasSuperAdminAccess();
			String createdBy = StringUtils.hasText(existingSubscriptionVO.getCreatedBy())
					? existingSubscriptionVO.getCreatedBy()
					: null;
			isOwner = (createdBy != null && createdBy.equals(userId));
		}

		if (!isAdmin && !isOwner) {
			MessageDescription notAuthorizedMsg = new MessageDescription();
			notAuthorizedMsg.setMessage(
					"Not authorized to delete subscription. Only subscriber or an admin can delete the subscription.");
			LOGGER.debug(
					"Not authorized to delete subscription. Only subscriber or an admin can delete the subscription. subscription id {}",
					id);
			GenericMessage errorMessage = new GenericMessage();
			errorMessage.addErrors(notAuthorizedMsg);
			return new ResponseEntity<>(errorMessage, HttpStatus.FORBIDDEN);
		}

		SubscriptionVO subscriptionVO = null;
		String solutionId = null;
		if (existingSubscriptionVO != null) {
			solutionId = existingSubscriptionVO.getSolutionId();
			existingSubscriptionVO.setUpdatedBy(userId);
			existingSubscriptionVO.setUpdatedDate(new Date());
			existingSubscriptionVO.setRecordStatus(ConstantsUtility.DELETED);
			existingSubscriptionVO.setSolutionId(null);
			subscriptionVO = super.create(existingSubscriptionVO);
		} else {
			LOGGER.debug("No Subscription found for given identification id {}", id);
		}

		if (StringUtils.hasText(solutionId)) {
			LOGGER.debug("Calling dna backend to unsubscribe solution with subscriptionId {}", id);
			dnaClient.updateSubscriptionAppIdInSolution(solutionId);
			LOGGER.info("Solution unsubscribed successfully");
		}
		if (subscriptionVO != null && subscriptionVO.getId() != null) {
			GenericMessage successMsg = new GenericMessage();
			successMsg.setSuccess("Success");
			LOGGER.info("Subscription deleted successfully for id {}", id);
			return new ResponseEntity<>(successMsg, HttpStatus.OK);
		} else {
			MessageDescription exceptionMsg = new MessageDescription("Failed to delete subscription");
			GenericMessage errorMessage = new GenericMessage();
			errorMessage.addErrors(exceptionMsg);
			LOGGER.debug("Subscription deletion Failed for id {}", id);
			return new ResponseEntity<>(errorMessage, HttpStatus.NOT_FOUND);
		}

	}

	/**
	 * Refresh apiKey based on given appId
	 * 
	 * @param appId
	 * @return SubscriptionVO
	 */
	@Override
	@Transactional
	public SubscriptionVO refreshApiKeyByAppId(String appId, String userId, SubscriptionVO existingSubscriptionVO) {
		if (existingSubscriptionVO != null && StringUtils.hasText(existingSubscriptionVO.getAppId())) {
			String apiKey = UUID.randomUUID().toString();
			VaultGenericResponse vaultResponse = vaultConfig.createApiKey(appId, apiKey);
			if (vaultResponse != null && "200".equals(vaultResponse.getStatus())) {
				LOGGER.info("Api Key refreshed successfully for appId {}", appId);
				existingSubscriptionVO.setApiKey(apiKey);
				existingSubscriptionVO.setUpdatedBy(userId);
				existingSubscriptionVO.setUpdatedDate(new Date());
				// subscriptionVO.setRecordStatus(ConstantsUtility.OPEN);
				SubscriptionVO responseSubscriptionVO = super.create(existingSubscriptionVO);
				responseSubscriptionVO.setApiKey(apiKey);
				return responseSubscriptionVO;
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

	@Override
	@Transactional
	public ResponseEntity<SubscriptionResponseVO> updateSolIdForSubscribedAppId(
			SubscriptionProvisionRequestVO subscriptionProvisionRequestVO) {
		SubscriptionResponseVO response = new SubscriptionResponseVO();
		String appId = "";
		try {
			SubscriptionVO existingSubscriptionVO = null;
			SubscriptionProvisionVO vo = subscriptionProvisionRequestVO.getData();
			String currAppId = vo.getCurrDnaSubscriptionAppId();
			String solutionId = vo.getSolutionId();
			String prevAppId = vo.getPrevDnaSubscriptionAppId();
			if (StringUtils.hasText(currAppId)) {
				existingSubscriptionVO = super.getByUniqueliteral("appId", currAppId);
				appId = currAppId;

			} else if (StringUtils.hasText(prevAppId)) {
				existingSubscriptionVO = super.getByUniqueliteral("appId", prevAppId);
				appId = prevAppId;
			}

			if (existingSubscriptionVO != null && existingSubscriptionVO.getRecordStatus() != null
					&& !existingSubscriptionVO.getRecordStatus().equalsIgnoreCase(ConstantsUtility.DELETED)) {
				CreatedByVO currentUser = this.userStore.getVO();
				String userId = currentUser != null ? currentUser.getId() : "";
				boolean isAdmin = false;
				boolean isOwner = false;
				if (StringUtils.hasText(userId)) {
					isAdmin = this.userStore.getUserInfo().hasSuperAdminAccess();
					String createdBy = StringUtils.hasText(existingSubscriptionVO.getCreatedBy())
							? existingSubscriptionVO.getCreatedBy()
							: null;
					isOwner = (createdBy != null && createdBy.equals(userId));
				}

				if (!isAdmin && !isOwner) {
					List<MessageDescription> messages = new ArrayList<>();
					MessageDescription notAuthorizedMsg = new MessageDescription();
					notAuthorizedMsg.setMessage(
							"Not authorized to update subscription. Only subscriber or an admin can update subscription.");
					messages.add(notAuthorizedMsg);
					response.setErrors(messages);
					return new ResponseEntity<>(response, HttpStatus.FORBIDDEN);
				}

				existingSubscriptionVO.setSolutionId(solutionId);
				existingSubscriptionVO.setUpdatedBy(userId);
				existingSubscriptionVO.setUpdatedDate(new Date());
				SubscriptionVO subscriptionVO = super.create(existingSubscriptionVO);
				if (subscriptionVO != null && subscriptionVO.getId() != null) {
					response.setData(subscriptionVO);
					LOGGER.debug("Subscription updated for appId {}", appId);
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					LOGGER.debug("Failed to update subscription for appId {} ", appId);
					List<MessageDescription> messages = new ArrayList<>();
					MessageDescription errMsg = new MessageDescription();
					errMsg.setMessage("Failed to update subscription");
					response.setErrors(messages);
					return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
				}

			} else {
				LOGGER.debug("No Subscription found for given appId {}", appId);
				List<MessageDescription> messages = new ArrayList<>();
				MessageDescription errMsg = new MessageDescription();
				errMsg.setMessage("No Subscription found for given appId");
				response.setErrors(messages);
				return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
			}
		} catch (Exception e) {
			LOGGER.error("Error occured while updating subscription for appId {} exception is : {}", appId,
					e.getMessage());
			List<MessageDescription> messages = new ArrayList<>();
			MessageDescription errMsg = new MessageDescription();
			errMsg.setMessage(e.getMessage());
			response.setErrors(messages);
			return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}

	@Override
	@Transactional
	public SubscriptionVO updateSubscription(String userId, SubscriptionExpireVO expireVO) {
		AppSubscriptionNsql responseEntity = null;
		AppSubscriptionNsql entity = customRepo.findbyUniqueLiteral("appId", expireVO.getAppId());
		if (!ObjectUtils.isEmpty(entity) && !ObjectUtils.isEmpty(entity.getData())) {
			entity.getData().setUpdatedBy(userId);
			entity.getData().setUpdatedDate(new Date());
			if (StringUtils.hasText(expireVO.getDescription())) {
				entity.getData().setDescription(expireVO.getDescription());
			}
			entity.getData().setExpiryDays(expireVO.getExpiryDays());
			entity.getData().setExpireOn(setExpiryDate(expireVO.getExpiryDays(), expireVO.getTimeZone()));
			responseEntity = jpaRepo.save(entity);
		}
		LOGGER.info("Updating subscription for appId {} , expiryDays {} ", expireVO.getAppId(),
				expireVO.getExpiryDays());
		return appSubscriptionAssembler.toVo(responseEntity);
	}

	/**
	 * <p>
	 * To return App subscription identified by Id
	 * </p>
	 * 
	 * @param Id
	 * @return SubscriptionVO
	 */
	@Override
	@Transactional
	public SubscriptionVO getById(String id) {
		SubscriptionVO subscriptionVO = super.getById(id);
		if (!ObjectUtils.isEmpty(subscriptionVO)) {
			VaultResponse vaultResponse = vaultConfig.getApiKeys(subscriptionVO.getAppId());
			if (vaultResponse != null && vaultResponse.getData() != null
					&& vaultResponse.getData().get(subscriptionVO.getAppId()) != null) {
				subscriptionVO.setApiKey(vaultResponse.getData().get(subscriptionVO.getAppId()).toString());
			}
		}
		return subscriptionVO;
	}

	private Date setExpiryDate(Integer expiryDays, String timeZone) {
		Date expiryDate = null;
		if (expiryDays != null) {
			if (expiryDays == -1) {
				expiryDate = new Date();
			} else if (expiryDays >= 0) {
				LocalDateTime currentDateTime = LocalDateTime.now();
				ZoneId zoneId = ZoneId.of(timeZone);
				ZonedDateTime zoneDateTime = ZonedDateTime.of(currentDateTime, zoneId);
				ZonedDateTime expiryDateTime = zoneDateTime
						.plusDays(expiryDays)
						.with(LocalTime.MIDNIGHT).withHour(23).withMinute(59).withSecond(59);
				expiryDate = Date.from(expiryDateTime.toInstant());
			} else {
				expiryDate = null;
			}
		}
		return expiryDate;
	}

	@Override
	public boolean isApplicationSubscriptionExist(SubscriptionVO requestSubscriptionVO, String userId) {
		List<AppSubscriptionNsql> entityList = customRepo.getAllWithFilters(userId, false, ConstantsUtility.OPEN, null,
				null, null, 0, 0, requestSubscriptionVO.getAppName(), null);
		return !ObjectUtils.isEmpty(entityList);
	}
}
