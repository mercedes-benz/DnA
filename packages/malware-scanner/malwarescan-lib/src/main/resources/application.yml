spring:
  mvc.pathmatch.matching-strategy: ant_path_matcher
  application:
    name: daimler-mbc-dna-malware-scanner
    version: 3.1.7
  profile:
    active: production
  flyway:
    enabled: ${FLYWAY_ENABLED:true}
    baseline-on-migrate: ${FLYWAY_BASELINE_ON_MIGRATE:true}
    baselineVersion: ${FLYWAY_BASELINEVERSION:0}
    schemas: ${FLYWAY_SCHEMA:public}
    
  jpa:
    database: POSTGRESQL
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        temp:
          use_jdbc_metadata_defaults: false
    hibernate:
      ddl-auto: none

  datasource:
    hikari:
      connection-timeout: 4000
    platform: postgres
    url: ${API_DB_URL:jdbc:postgresql://localhost:5432/malware}
    username: ${API_DB_USER:XXXX_user}
    password: ${API_DB_PASS:XXXX_pass}
    driverClassName: org.postgresql.Driver    
    
  servlet:
    multipart:
      max-file-size: ${MAX_FILE_SIZE:10MB}
      max-request-size: ${MAX_REQUEST_SIZE:11MB}
  cache:
    jcache:
      config: classpath:ehcache.xml

  kafka:
    producer:
    properties:
      ssl:
        truststore:
          location: ${TRUSTSTORE_PATH:/XXXX/XXXX/truststore.jks}
          password: ${TRUSTSTORE_PASSWORD:XXXX}
          type: PKCS12
        keystore:
          location: ${KEYSTORE_PATH:/XXXX/XXXX/keystore.p12}
          password: ${KEYSTORE_PASSWORD:XXXX}
          type: PKCS12
      security:
          protocol: SSL    
  cloud:
    stream:
      default-binder: kafka
      kafka:
        binder:
          brokers: ${NAAS_BROKER:localhost:9092}
    vault:
      uri: ${VAULT_URI:xxxx}
      namespace: ${VAULT_NAMESPACE:xxxx}
      mountpath: ${VAULT_MOUNTPATH:xxxx}
      authentication: ${VAULT_AUTHENTICATION:xxxx}
      kubernetes:
        role: ${VAULT_ROLE:xxxx}
        service-account-token-file: ${KUBERNETES_SA_TOKEN_PATH:xxxx}
        kubernetes-path: ${VAULT_AUTH_PATH:xxxx}
      vaultpath: ${VAULT_PATH:xxxx}
      kv:
       enabled: true  
      ssl:
        enabled: false
        trust:
          store:
            path: ${CA_TRUSTSTORE_PATH:/XXXX/XXXX/truststore.p12}
            password: ${CA_TRUSTSTORE_PASSWORD:XXXX}

task.alert.before-expiry-duration: ${EXPIRY_DAYS:5}

kafka:
  centralTopic:
    name: dnaCentralEventTopic 
      
dna:
  uri: ${DNA_URI:xxxx}
  verifyLoginApi: ${DNA_VERIFY_LOGIN_API:/api/verifyLogin}
  unsubscribeMalwareScanApi: ${DNA_UNSUBSCRIBE_MALWARE_SCAN_API:/api/malwarescan/unsubscribe/}  
      
jwt:
  secret:
    byPassUrl: ${BYPASS_JWT_AUTHENTICATION:/scan/health;/scan/upload}    

server:
  port: 8181

#Cors Filter origin Domains  
allowedCorsOriginPatternUrl: ${CORS_ORIGIN_URL:http://*}    

clamavservice:
  uploadDir: /tmp
  clamAvHost: ${CLAMAV_BACKEND_URL:localhost}
  clamAvPort: ${CLAMAV_BACKEND_PORT:3310}


malware:
    api:
    basicAuth: 
      token: ${ONEAPI_BASICAUTH_TOKEN:XXXXX}
bucket4j:
  enabled: true
  filters:
  - cache-name: buckets
    url: ${RESTRICTED_URL_PATTERN:/avscan/api/v1/scan.*}
    http-response-body: "{ \"success\": \"Too Many Requests\", \"errors\": [{ \"message\": \"You have exhausted your API Request Quota\" }],\"warnings\": null}"
    strategy: first
    rate-limits:
    - expression:  "getHeader('appId')"
      bandwidths:
      - capacity: ${API_REQUEST_LIMIT:1}
        time: ${WITH_IN:20}
        unit: ${TIME_UNIT:seconds}     

swagger.headers.authorization.token: ${SWAGGER_HEADER_AUTH:XXXXXX}        
management.endpoints.web.exposure.include: loggers,health
management.endpoint.loggers.enabled: true
management.endpoint.health.probes.enabled: true
management.endpoint.health.show-details: always

logging:
  service:
    environment: ${LOGGING_ENVIRONMENT:DEV}
    path: ${LOGGING_PATH:/logs}
  level:
    com:
      daimler:
        mbc:
          dna:
            malwarescanner: INFO
    org.springframework.boot.autoconfigure.logging: INFO
